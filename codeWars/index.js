class Ball {
    constructor(ballType) {
        if (ballType) {
            this.ballType = ballType
        } else {
            this.ballType = 'regular'
        }
    }
}


// 1  //В этом простом упражнении вы создадите программу, которая будет принимать два списка целых чисел a и b. Каждый список будет состоять из 3 положительных целых чисел выше 0, представляющих размеры кубоидов a и b. Вы должны найти разницу объемов кубоидов независимо от того, какой из них больше.
//
// Например, если переданы параметры ([2, 2, 3], [5, 4, 1]), объем a равен 12, а объем b равен 20. Следовательно, функция должна вернуть 8.
//
// Ваша функция будет проверена как на готовых, так и на случайных примерах.
//
// Если можете, попробуйте написать это одной строкой кода.


let start = [1, 7, 6] //14
let end = [2, 3, 4]  // 9

const func = (start, end) => {

    return Math.abs(start.reduce((acc, el) => acc * el) - end.reduce((acc, el) => acc * el))
}

// console.log(func(start, end))


//    2     //
// Ваша функция принимает два аргумента:
//
//     текущий возраст отца (лет)
// текущий возраст сына (лет)
// Подсчитайте, сколько лет назад отец был вдвое старше сына (или через сколько лет он будет вдвое старше).

const fatheAge = 40
const sunAge = 23

const funcAge = (fatheAge, sunAge) => {
    let years = sunAge * 2
    return fatheAge > years
        ? fatheAge - years : Math.abs(years - fatheAge)
}

// console.log(funcAge(40, 23))

//      3      ///

// Вам даны два отсортированных массива, которые содержат только целые числа. Ваша задача найти способ объединить их в один, отсортированный по возрастанию. Завершите функцию mergeArrays (arr1, arr2), где arr1 и arr2 - исходные отсортированные массивы.
//
// Вам не нужно беспокоиться о проверке, поскольку arr1 и arr2 должны быть массивами с 0 или более целыми числами. Если и arr1, и arr2 пусты, просто верните пустой массив.
//
// Примечание: arr1 и arr2 могут быть отсортированы в разном порядке. Также arr1 и arr2 могут иметь одинаковые целые числа. Удалите дубликаты в возвращенном результате.


function mergeArrays(arr1, arr2) {

    const arr = arr1.concat(arr2).sort((a, b) => a - b)
    return [...new Set(arr)]

}

//  4  ///  устранить все ошибки из предоставленного кода, чтобы код работал и выводил ожидаемое значение. Выведите длину самого длинного слова в виде числа.
//
// Будет только одно «самое длинное» слово.

let str = "The quick white fox jumped around the massive dog"

// console.log(str.split(' '));
let spl = str.split(' ')
let longest = 0

const funk1 = () => {
    for (let el of spl) {
        if (el.length > longest) {
            longest = el.length
        }
    }
    return longest
}
// console.log(funk1(arr))


/// 5  //// напишите мне функцию stringy, которая принимает размер и возвращает строку чередующихся «1» и «0».
//
// строка должна начинаться с 1.
//
// строка размером 6 должна вернуть: «101010».
//
// размер 4 должен вернуть: «1010».
//
// размер 12 должен вернуть: «101010101010».
//
// Размер всегда будет положительным и будет использовать только целые числа.


const stringy = (size) => {
    let string = '1'
    for (let i = 0; i < size - 1; i++)
        if (i % 2 === 0) {
            string += '0'
        } else {
            string += '1'
        }
    return string
}

// console.log(stringy(12));


//////     6      ///////   Реализуйте функцию, которая преобразует данное логическое значение в его строковое представление.
//
// Примечание. Будут предоставлены только действительные входные данные.

function booleanToString(b) {
    return b ? 'True' : 'False'
}

// console.log(booleanToString(false));


// Задача
// Учитывая список чисел, верните список так, чтобы значения увеличивались на 1 для каждого индекса до максимального значения.


const arr = [1, 5, 6, 11]

function pipeFix(numbers) {                     //   НЕ ЗАКОНЧЕНАААААААААА
    let res = []
    let min = numbers[0]
    let max = numbers[numbers.length - 1]
    for (let el of numbers) {
        if (min < max) {
            res.push(el)
        }
    }
    // console.log(res)
}

pipeFix(arr)


//Цель этого ката - выяснить, сколько бутылок виски беспошлинной торговли вам нужно будет купить, чтобы экономия по сравнению с обычной средней ценой эффективно покрыла расходы на ваш отпуск.
//
// Вам будет предоставлена ​​стандартная цена (normPrice), скидка в дьюти-фри (скидка) и стоимость праздника.
//
// Например, если бутылка обычно стоит 10 фунтов стерлингов, а скидка в дьюти фри составляет 10%, вы сэкономите 1 фунт стерлингов на каждой бутылке. Если ваш отпуск стоит 500 фунтов стерлингов, ответ, который вы должны вернуть, будет 500.
//
// Все входные данные будут целыми. Пожалуйста, верните целое число. Округлить.


function dutyFree(normPrice, discount, hol) {
    return Math.floor(hol / (normPrice * (discount / 100)))
}

dutyFree(12, 50, 1000)

// Ваши входные данные: положительное целое число n, большее или равное единице. n предоставляется, у вас НЕТ КОНТРОЛЯ над его значением.
//
// Ожидаемый результат - это массив положительных целых чисел от 1 до n (включительно).
//
// Ваша задача - написать алгоритм, который проведет вас от входа к выходу.


function preFizz(n) {
    let arr = []
    for (let i = 1; i <= n; i++) {
        arr.push(i)
    }
    return arr
}

//Я хотел бы передать массив с двумя элементами в мою функцию swapValues, чтобы поменять местами значения. Однако похоже, что значения не меняются.
//
// Вы можете понять, что здесь не так?


function swapValues(arr) {
    return arr.reverse();
}


//Дети пьют тодди.
// Подростки пьют кокаин.
// Молодые люди пьют пиво.
// Взрослые пьют виски.
// Сделайте функцию, которая получает возраст и возвращает то, что они пьют.
//
// Правила:
//
// Детский до 14 лет.
// Подростки до 18 лет.
// Молодые до 21 года.
// Взрослым от 21 года.

function peopleWithAgeDrink(old) {
    if (old <= 13) {
        return "drink toddy"
    }
    if (old >= 14 && old < 18) {
        return "drink coke"
    }
    if (old >= 18 && old < 21) {
        return "drink beer"
    }
    if (old >= 21) {
        return "drink whisky"
    }
};


// Напишите функцию gooseFilter / goose-filter / goose_filter / GooseFilter, которая принимает массив строк в качестве аргумента и возвращает отфильтрованный массив, содержащий те же элементы, но с удаленными «гусями».
//
// Гуси - это любые строки в следующем массиве, который предварительно заполняется в вашем решении:
// Элементы в возвращаемом массиве должны быть в том же порядке, что и в исходном массиве, переданном вашей функции, хотя и без «гусей». Обратите внимание, что все строки будут в том же регистре, что и предоставленные, и некоторые элементы могут повторяться.

function gooseFilter(birds, geese) {
    let resArr = [...birds, ...geese]
    let uniq = resArr => [...new Set(resArr)];   //  //   НЕ ЗАКОНЧЕНАААААААААА

};

gooseFilter(["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"], ["Mallard", "Hook Bill", "Crested", "Blue Swedish"])


//Implement a function named generateRange(min, max, step), which takes three arguments and generates a range of integers from min to max, with the step. The first integer is the minimum value, the second is the maximum of the range and the third is the step. (min < max)

function generateRange(min, max, step) {
    let result = []
    for (let i = min; i <= max; i = i + step) {
        result.push(i)
    }
    return result
}


// Боб работает водителем автобуса. Однако он стал чрезвычайно популярным среди жителей города. Когда так много пассажиров хотят сесть в его автобус, ему иногда приходится сталкиваться с проблемой нехватки места в автобусе! Он хочет, чтобы вы написали простую программу, сообщающую ему, сможет ли он вместить всех пассажиров. Обзор задачи:
//   Вам нужно написать функцию, которая принимает три параметра:
/*    cap - это количество людей, которое может вместить автобус, за исключением водителя.
    on - это количество людей в автобусе без водителя.
    wait - это количество людей, ожидающих сесть в автобус, за исключением водителя.
    Если места достаточно, верните 0, а если его нет, верните количество пассажиров, которых он не может взять.*/

// cap = 10, on = 5, wait = 5 --> 0 # He can fit all 5 passengers
// cap = 100, on = 60, wait = 50 --> 10 # He can't fit 10 of the 50 waiting
//
function enough(cap, on, wait) {
    return wait > (cap - on) ? wait - (cap - on) : 0
}


const enough1 = (cap, on, wait) => {
    (wait > (cap - on) ? wait - (cap - on) : 0)
}

// Иногда мне нужно быстро преобразовать мили на британский галлон в километры на литр.
//
// Создайте приложение, которое будет отображать количество километров на литр (вывод) на основе количества миль на британский галлон (ввод).
//
// Обязательно округлите результат до двух десятичных знаков. Если ответ заканчивается на 0, его следует округлить без 0. Таким образом, вместо 5,50 мы должны получить 5,5.
//
// Некоторые полезные ассоциации, относящиеся к этому ката: 1 британский галлон = 4,54609188 литров 1 миля = 1,609344 километра

function converter(mpg) {
    //code to convert miles per imperial gallon to kilometers per liter   //   НЕ ЗАКОНЧЕНАААААААААА
}


// Write a function to convert a name into initials. This kata strictly takes two words with one space in between them.
//
// The output should be two capital letters with a dot separating them.
//
// It should look like this:
//
// Sam Harris => S.H
//
// Patrick Feeney => P.F



function abbrevName(name) {
    let letters = [];
    const b = name.split` `
    b.forEach((el, i) => letters.push(el[0]))
    return letters.join('.').toUpperCase()
}


console.log(abbrevName('Dima Doroshenko'));









